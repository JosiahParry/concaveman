% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/concaveman.R
\name{concaveman}
\alias{concaveman}
\title{A very fast 2D concave hull algorithm}
\usage{
concaveman(points, by = NULL, concavity = 2, length_threshold = 0)
}
\arguments{
\item{points}{an object of class \code{sf} containing points}

\item{by}{the (unquoted, tidyverse-style) name of the variable defining the subsets of points for which concave hull polygons should be computed. If \code{NULL} (the default), only one polygon is computed for the whole set of points.}

\item{concavity}{a relative measure of concavity. 1 results in a relatively detailed shape, Infinity results in a convex hull. You can use values lower than 1, but they can produce pretty crazy shapes.}

\item{length_threshold}{when a segment length is under this threshold, it stops being considered for further detalization. Higher values result in simpler shapes.}
}
\value{
an \code{sf} object holding the polygon(s) and, if there is one, the \code{by} column.
}
\description{
The \code{concaveman} function ports the \href{https://github.com/mapbox/concaveman}{concaveman} library from mapbox. It computes the concave polygon(s) for one or several set of points.
}
\details{
For details regarding the implementation, please see the original javascript library \href{https://github.com/mapbox/concaveman}{github page}. This is just a thin wrapper, via \href{https://cran.r-project.org/web/packages/V8/}{V8}. I only have introduced some sort of vectorisation: using the \code{by} argument, you can compute the polygons for a number of subsets of points.
}
\examples{
library(tmap)
data(points)
polygons <- concaveman(points, k)
tm_shape(points) +
 tm_dots(col = "k", size = 0.1, legend.show = FALSE) +
tm_shape(polygons) +
 tm_fill(col = "k", alpha = 0.5, legend.show = FALSE)

}
